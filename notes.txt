https://github.com/jonasschmedtmann/complete-javascript-course

JavaScript is a high level prototype based object oriented multi paradigm interpreted or just-in-time compiled,dynamic,single threaded,garbage collected programing language with first class non blocking and event loop concurrency model.

high-level: js manages hadrware resources automatically.
garbage-collected: alogirthm inside javascript that automatically removes/destroys old and un-used objects 
interpreted or just-in-time compiled: javascript engine uses just in time compiler and interpreter mix to covert  code to machine code.
multi-paradigm: javascript is mix of procedural programing , object oriented programming and functonal programing.
prototype-based object oriented: Almost evreything except primitive value in js is defined as object internally , but when we create arrays in js we create a prototype version of the javascript Array class object and so our array inherits method of the proptyped Array objecet.
First-class function: Function are treated just as regular variables.
dynamic typed: we dont assign data type to variable and they are automatically decided by js based on the type of value the variable holds. 
single threaded & non-blocking event loop: javascript itself runs in one single thread but jav still manages to perform non blocking big task by a process called EventLoop , by this process it takes a long running task ,executes it in the background and puts it back in the main thread once its execution is finished.



JavaScript Engine and Runtime:
Js Engine is the program that runs javascript code. there are many js engines but the most well known is the google's V8 engine that powers google chrome and node.js,all the other browsers have their own js engine.

Js engine components:
Any js engine contains 2 major components 
    1. call Stack: The call stack is the stack area where all codes are executed and each entry in the call stack is called execution context.
    2. Heap: unstrtuctured memory pool that stores all the object that our application needs.

Compliation: entire code is converted to machine code and then  written to binary file that is then executed by machine
Interpretation: interpreter runs through the source code and executes it line by line.

Js used to be a purely interpreted language.but interpreted language had a drawback , they are slower than compiled languages.so mordern js uses mix of compilation and interpretation in the form of JIT( Just in time compiler) , compiles the entire code into machine code at once and then executed ,no binary file is created.


code -> Paresd and stored in tree sturcture called AST(Abstract Syntax Tree)-> Compilation the AST to machine code -> Execution 

Js runtime = js engine + Web API's + Callback queue(contains all the callback function that is ready to be executed.event loop puts this call back function when event occurs into the call stack)


Execution Context and The Call Stacks:

Execution context is an environment in which a piece of javascript is executed .Stores all the necessary information for some code to be executed.such as local variables , arguments passed ,etc.

comlilation
    -> Creation of global exectution context for (for top level code that is not part of any function {global scope code} the global scope is executed before function code)
        -> Execution of the top/global level code.
            -> New execution context for each and evrey function/methods.


Scope and Scope chain:
Scope chains establish the scope for a given function. Each function defined has its own nested scope, and any function defined within another function has a local scope which is linked to the outer function â€” this link is called the chain.

function parent() {
    var name = 'Aastha';
    console.log(name); 
    //  Reference error: age is not defined
    console.log(age); 
    //  Reference error: places is not defined
    console.log(places); 
  
    function child() { 
    // function linked to parent() thats why name is accessible.
    
        var age = 23;
        console.log(name);  
        console.log(age);
        //  Reference error: places is not defined
        console.log(places); 
        function grandchild() { 
        // this function is linked to child() & parent() thats why name, age are  accessible.
                var places = 'Coding';
                console.log(name);
                console.log(age);
                console.log(places);
        }
        grandchild();
    }
    child();
}
parent();
Please note, Any variable not declared without first being declared with the var keyword, it is automatically added to the global context which eventually becomes Global variable.

Hoisting:
JavaScript Hoisting refers to the process whereby the interpreter appears to move the declaration of functions, variables or classes to the top of their scope, prior to execution of the code.
Being able to use a variable's value in its scope before the line it is declared. ("Value hoisting")
Being able to reference a variable in its scope before the line it is declared, without throwing a ReferenceError, but the value is always undefined. ("Declaration hoisting")
The declaration of the variable causes behavior changes in its scope before the line in which it is declared.

Variables defined with let and const are hoisted to the top of the block, but not initialized.

Meaning: The block of code is aware of the variable, but it cannot be used until it has been declared.

Using a let variable before it is declared will result in a ReferenceError.


function decalted as variable and arrow function are not hoisted and cannot be called before definiton. only nuormal function with 'function declearation are hoisted by javascript




this keyword:
Special variable created for every execution context which points to the owner of the function or object in which the this keyword is used.In JavaScript, objects the this keyword refers to can be determined by how a function is called at runtime. In Java, the this keyword refers to current instance of an object defined by a class.
The following JavaScript example shows how an object stored in the global window object can be referenced with the this keyword.

var a = 1;
var getValue = function() {
  return this.a;
}
console.log(getValue()); //prints 1;

The next example shows how the this keyword can be bound to different values pending on how a function is called.

function bike() {
   console.log(this.name);
}
var name = "Ninja";
var obj1 = { name: "Pulsar", bike: bike };
var obj2 = { name: "Gixxer", bike: bike };
bike();           // "Ninja"
obj1.bike();      // "Pulsar"
obj2.bike();      // "Gixxer"
The this keyword refers to the window object when the bike function is called freely. When the bike function gets called as a method on an object, the this keyword refers to the object the method is being called upon at runtime. Therefore, obj1.bike()prints â€œPulsarâ€ and obj2.bike() prints â€œGixxerâ€.

arrow function this keyword differently because arrow function does not get its own 'this' keyword it will simply use the 'this' keyword of its surrounding and when defined inside an object if we use 'this' keyword of an arrow function defined inside an object the 'this' keyword in the arrow function will refer to the global window object and not the object in which it is defined 

const jonas ={
firstName: 'Jonas',
year:'1991',
calcAge:function(){
console.log(this);
console.log(2037-this.year);
},
greet:()=>{
console.log(`hey ${this.firstName}`);
}
};
jonas.greet(); // hey undefined
hence we should avoid using arrow function as a method inside an object



also when we call a method from withtin another method the this keyword for the inner method will be undefined 


const jonas ={
firstName: 'Jonas',
year:'1991',
calcAge:function(){
console.log(this);
console.log(2037-this.year);

const isMillenia :function(){
    console.log(this);//undefined
};
isMillenia();


},
greet:()=>{
console.log(`hey ${this.firstName}`);
}
};
jonas.calcAge();



but if we use an arrow function as the inner function to the function inside an object then as in arrow function does not have its own 'this' and it will simply use the 'this' keyword of its surrounding and since it is defined as an internal method to the outer function of the object it will use its this and hence point to the caller object.
const jonas ={
firstName: 'Jonas',
year:'1991',
calcAge:function(){
console.log(this);
console.log(2037-this.year);

const isMillenia: ()=>{
    console.log(this.age);//1991
};
isMillenia();


},
greet:()=>{
console.log(`hey ${this.firstName}`);
}
};
jonas.calcAge();


so moral of story is, if we want to define a method inside an object then we will use declerative function with function keyword and if we want to define an internal method inside a method/function in an object then for the inernal function we wont use function with function keywrod rather we use the arrow function. 

Role of js in web development:
    Html: responsible for the content of the web page.
    css:  responsible for the styling of the web page.
    js: actual programing language of the internet ,helps developer to add dynamic and interactive web pages , it is also used to manipulate content of css ,load data from the servers. popular js libraries like  react , angular , vue are all based on js.javascript can also run web server , node js is a big example where we use js outside web browser and as backend language to work on web servers.Js can also used to make native mobile and dekstop application with libraries like ract native ,ionic and electron js

    JavaScript releases(Ecma script)
    mordern js started from major change which was done in 2015 and known  as ES6 

    ...... ES5->ES6(2015)->ES7(2016)->ES8(2017)->ES9(2018)->ES10(2019)->ES11(2020)


    As we know that HTML is loaded and executed line by line. So, when the browser encounters a <script> tag, it loads and executes the javascript code on the spot. This may slow down the page rendering speed and thus webpage will take more time to load.
    Javascript is often used to manipulate DOM and add new functionality to the webpage. If <script> tag is not added at end of the <body> tag, DOM may not be ready by that time, thus preventing javascript to work on it, leading to unknown behaviors.
    Therefore, we should always add <script> tag at the end of the <body> tag to prevent unknown behaviors and make the webpage load faster.


    -----------------------------------------------------------------------------------------------------------------------------
    Data types:
    Data types in js are broadly classified into 2 type 
        a. Object type
        b. primitive type
    There are 7 primitive data type in Js:
        1. Number: Floating point numbers used for decimals and integers -> let a=23; let a=4.5
        2. String : Sequence of characters used for text decalared in quotes (double or single doesn't matter) -> let s='hello'; let s="hello";
        3. Boolean : Logical type that can only be true or false, used for decision making -> let isDecimal=true;
        4. Undefined: Value taken by variable that is not yet defined('empty value') ->  let children;[here childern contains undefined as it is decalared but not defined].
        5. Null: Also means empt value but used for differenet circumstances than undefined  if you want to indicate the absence of a deal explicitly, always use null instead of undefined to avoid confusion.
        6. Symbol(ES2015): Value that is unique and cannot be changed.
        7. BigInt(ES2020): Larger integers that number type can hold.


JavaScript has dynamic typing: we dont have to manually define the data type of the value stored in a variable. JS automatically determines the data type.

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
let and const are introduced in ES6 and var is old js

let keyword is used to declare variable whose value is subjected to be changed/re-assigned later
const keyword is used to decalare variable whose value is not changed once assigned.If we try to re-assign variable decalred with const then automatically javascript throws error.
also we cannot decalre const variable withour initialzing any value , else js will throw error.

var pretty much works similar to how let works.but internally var is different from let keyword ,variable declared by let are only available inside the block where they're defined
but variable decalred by var are created on global object and the scope available throughout the function in which they're declared.





------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
- <->  subtraction
+ <-> for number addition and in case of string its concatination
** <-> power operation( 2**3) == 2^3
typeOf <-> returns the type of a given value
= <-> equals assignment operator
+= <-> increment assignment (x+=10   === x=x+10) 
*= <-> multiply assignment operator (x*=4 === x=x*4)
++ <-> increment operator
-- <-> decrement  operator

comparision operator

> -> greater then
< -> lesser than 
>= greater then or equal to 
<= less than or equal to 

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

operator precedence
Check this link for complete operator precedence
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_precedence#table

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

In js we have a more flexible way of concating string with value of varriable called as template format where the string is enclosed in `(backtick) instead of double or single quotes
and inside that portion in order to print value of the varriable we have to just encapsulate the variable with ${variiable_name}
eg: console.log(`Mark's BMI (${markBMI}) is greater then jhon's BMI (${jhonBMI})`
here  markBMI and jhonBMI are varriable whose values will be used inside the string , we can also use backtick for regular string so its safe to use backtick instead of single or double for using normal or template string format.we can also use backtick to pring multi-line string which in case of quoted string we had to use escape character like \n or \t etc.


---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


Type conversion and type coercion

When we manually convert one data type to another its called type conversion and when JavaScript automatically converts the type behind the scene its called type coercion.

Number(value) -> will convert any valid string to number if the string is not a valid number it will return NaN (Not a number)
Number("1991") -> 1991(number)
Number ("jonas")-> NaN
typeOf(NaN)-> number 


String(value)-> converts to string


Js does type coercion for us in many ways

console.log("i am " + 23 + "years old"); // here js is automatically converting 23 which is a number to string via + concat operation.

console.log('23' - '10' - 3); //here js will use type coercion from string to number 

console.log('23' + '10' + 3); // but here it will do type coercion from number to string as + will be used as concat operation not arithemetic sum.

console.log('23' * 3); //  here js will convert from string to number 

let n = '1' + 1;// it will result in 11
n = n - 1;// here n which was string 11 in the above line will be automatically converted to number 11 for - operation 
console.log(n)// 10



console.log(2 + 3 + 4 + '5');//95 (2+3+4)=9 this is arithmetic addition but last + with '5 will be string concatination
console.log('10' - '4' - '3' - 2 + '5')//15 here ('10' - '4' - '3'  -2 )is arithemtic subtraction resulting in 1 and then +'5' is string concatination resulting in 15


while adding number to string + will always work as string concat and not arithemetic sum.


---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


truthy and falsy values

falsy values are values that are not exactly false but will become false when we try to convert them to Boolean
in js there are 5 falsy values they are:
    1. 0
    2. '' (empty string)
    3. null 
    4. undefined
    5. NaN
    
evey other value other than the above 5 are truthy value 

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


== vs ===

=== is a strict equality opearator it returns true when both the values are exactly the same and does not perform type coercion

18===18 -> true
18===19 -> false
18==='18' -> false // don't perform coercion

== loose equality operator and perform type coercion 
'18'==18 -> true // performs type coercion


== operator is useful when you need explicit type converstion for example you are a number as input from a textbox and want to check the number then == will perform type coercion and then perform check 
but  in goor programing practice is to convert the string explicitly using Number() function and then check with === operator.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

strict mode : use strict; -> this line should be the first line in your script to enable strict mode The purpose of "use strict" is to indicate that the code should be executed in "strict mode".With strict mode, you can not, for example, use undeclared variables.another thig strict mode does is to introduce a short list of variable names that are reserved for features that might be added to the language later.in normal JavaScript, mistyping a variable name creates a new global variable. In strict mode, this will throw an error, making it impossible to accidentally create a global variable.In normal JavaScript, a developer will not receive any error feedback assigning values to non-writable properties.
In strict mode, any assignment to a non-writable property, a getter-only property, a non-existing property, a non-existing variable, or a non-existing object, will throw an error.


---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Functions:

Function is a piece of code that can be reused several times .

syntax fod defining a function:

function <function_name>(<list of parameters of nothing if no parameters are taken as input>)
{
//body of the function

}

syntax for calling a function

<functionName>(values of the parameter decalred in the function or nothing if there is no parameter)

Function declearations vs Expression


/declarative function
function calAge1(birtyYear) {
    return now - birtyYear;
}
console.log(calAge1(1991));

//annonymus function or function defined as expression
const calAge2 = function (birtyYear) {
    return now - birtyYear;
}

console.log(calAge2(1992))



in case of declarative type function we can call the function before defining the function
console.log(calAge1(1991));
/declarative function
function calAge1(birtyYear) {
    return now - birtyYear;
}
but in case of annonymus or expression function we cannot do call the function before the expression , this is because of hoisting 

Hoisting refers to the process whereby the interpreter appears to move the declaration of functions, variables or classes to the top of their scope, prior to execution of the code

//Arrow function
//for arrow function if we have only 1 line in the function we don't need {} and return statement explicitely 
const calAge3 = birthYear => now - birthYear;
console.log(calAge3(1995));

//but if arrow function has more than 1 statement then {} and return statment is needed if the function returns value
const yearsUntilRetirement = birthYear => {
    const age = now - birthYear;
    return 65 - age;
}
console.log(yearsUntilRetirement(1995))


//for multiple parameters/arguments we have to use () and separate each arg with ','

const yearsUntilRetirement2 = (birthYear, name) => {
    const age = now - birthYear;
    return `${name} has ${65 - age} years till retirement`;
}
console.log(yearsUntilRetirement2(1995, 'jonas'))

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


//Arrays
//literal syntanx
const friends = ['michael', 'stepehen'];
console.log(friends);
// seccond way of creating array with new keyword
const years = new Array(1991, 1984, 2008);
console.log(years);
//like java in js also array index starts from 0
//print length of array
console.log(years.length)
//only primitive value in js are immutable so even if we assign an array or object type in const we can change the element of array and property of the object
friends[1] = 'rahul';
console.log(friends);
//we cannot a new array to the same const variable
arrays in javascript are hetrogenous ,i,e. can store mutli type data


Some Basic array operations

//some basic array methods

friends.push('Vicky');// Appends new elements to the end of an array, and returns the new length of the array.
console.log(friends);

friends.unshift('Jhon'); //  Inserts new elements at the start of an array, and returns the new length of the array.
console.log(friends);

friends.pop();//Removes the last element from an array and returns it, If the array is empty, undefined is returned and the array is not modified.
console.log(friends);


friends.shift(); //Removes the first element from an array and returns it. If the array is empty, undefined is returned and the array is not modified.
console.log(friends);
console.log(friends.indexOf('stepehen')) // Returns the index of the first occurrence of a value in an array, or -1 if it is not present.

console.log(friends.includes('stepehen')) // Determines whether an array includes a certain element, returning true or false as appropriate. checks for strict equality(=== and not ==) also has an optional parameter of starting index from where you want to begin search


---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Objects:
Objects are building block of oops programing, object is representation of real world entity having key value pair where each key represnt an attribute of the entity


//objects

const jonas = {
    firstName: 'jonas',
    lastName: 'david',
    age: 2037 - 1997,
    job: 'teacher',
    friends: ['vick', 'sam']
}
console.log(jonas)


//there are 2 ways we can access an object using the dot operator or bracket,while accesing with dot operator we have to strictly use the property name of the object, but with [] we can write expression inside the [] that will be evaluated and mapped as the property,it is best to use ['<property name>'] when we are dynamically generating the property name
// when we try to access a property in an object that is not present then it returns undefined

console.log(jonas.firstName);
console.log(jonas['firstName']);
const nameConst = 'Name';
console.log(jonas[`last${nameConst}`]);

Note: Objects can store primitive data as value , array as value , another object as a value and even function as a value in its key value pair

Object methods:


const jonas2 = {
    firstName: 'jonas',
    lastName: 'david',
    birthYear: 1999,
    hasDriverLicence: true,
    calcAge: function () {
        //in javascript like java we have a this kery word which when used inside the object reffers to itself and we can use the this keyword to access the propery of the calling object from within itself
        //the this.age keyword will create a new property name age as it did not existed 
        this.age = 2037 - this.birthYear;
        return this.age;
    },
    summaryFunction: function () {
        this.summary = `${this.firstName} is a ${this.calcAge()} old ${this.job} and ${this.hasDriverLicence ? 'a' : 'no'} driver's licence`;
        return this.summary;

    },
    job: 'teacher',
    friends: ['vick', 'sam']
};


console.log(jonas2['calcAge']()); //here calcAge method will be called and the result will be stored in age property created inside the function
console.log(jonas2.age);
console.log(jonas2.summaryFunction());
console.log(jonas2.summary);
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

//loops

//for loop

for (let i = 1; i <= 10; i++) {
    console.log(`Hello world ${i}`)
}

// one of the most use of for loop is to loop through arrays
for (let i = 0; i < friends.length; i++) {
    console.log(friends[i])
}

const ages = [];
for (let i = 0; i < years.length; i++) {
    ages.push(2037 - years[i]);
}
console.log(ages);

//while loop
let i = 0
while (i < years.length) {
    console.log(years[i]);
    i++;
} i = 0
//do while loop
do {
    console.log(years[i]);
    i++;
} while (i < years.length)

break and continue statement are same as java.


Dom manipulation using javascript

Dom: Document object model which is a structured representation of html documents.Allows javascript to access html elements and styles to manipulate them.connecting point between html elements and javascript code.Dom is automatically created by the browser as soon as the html page loads in a tree structure, in that tree strucutre evrey node is an html object arranged in hierarchy of the html objects.

document is the root of the tree and it is followed by child node named html as <html></html> is the root most tag of a html page


eg: 
        document:
            element(<html>)
                element(<head>)
                    element(<title>)
                        element(<text>)
                element(<body>)
                    element(<section>)
                        element(<p>)
                            element(<text>)
                            element(<a>)
                                element(<link>)
                    element(<section>)


Dom is not part of javascript,dom and dom methods are part of web API which are libraries that browser implements which we can access from JavaScript code.Beside DOM there tons of other API like fetch api , time api etc.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Ds,Mordern operators and string in javascript.

Array Destructering: Its an ES6 feature and its basically way of unpacking values from an array or object into seperate variables.

'use strict';
const resturant = {
  name: 'Classico Italiano',
  location: 'Via Angelo Tavanti 23, Firenze, Italy',
  categories: ['Italian', 'Pizzeria', 'Vegetarian', 'Organic'],
  starterMenu: ['Focaccia', 'Bruschetta', 'Garlic Bread', 'Caprese Salad'],
  mainMenu: ['Pizza', 'Pasta', 'Risotto'],
};

// destructering array before ES6
const arr = [1, 2, 3];
const a = arr[0];
const b = arr[1];
const c = arr[2];
console.log(arr);
console.log(a);
console.log(b);
console.log(c);

// destructering array after ES6
//now the three elements of the array will be automatically assigned to the three variables defined inside [] its called destructering assingments
const [x, y, z] = arr;
console.log(x);
console.log(y);
console.log(z);

//this will extract the first 2 elements of the categories array inside resturant object and assign that to the two varriables,if we want to skip elements of the array while de-structering then we add a blank there as show below
let [first, seccond] = resturant.categories;
console.log(first);
console.log(seccond);

// swapping without destrucring
const temp = first;
first = seccond;
seccond = temp;

console.log(first);
console.log(seccond);

//swapping with destructering.
[seccond, first] = [first, seccond];
console.log(first);
console.log(seccond);

//nested de-structering
const arrayofArray1 = [1, 2, [4, 5]];
console.log(arrayofArray1);
const [one, , [three, four]] = arrayofArray1;
console.log(one);
console.log(three);
console.log(four);

//setting default values while destructering

const arr2 = [1, 2, 3];
const [p, q, r, s] = arr2;
console.log(p, q, r, s); //1,2,3,undefined

const arr3 = [1, 2, 3];
const [i = 1, j = 2, k = 3, l = 99] = arr2;
console.log(i, j, k, l); //1,2,3,99


De-strutering objects:


const restaurant = {
  name: 'Classico Italiano',
  location: 'Via Angelo Tavanti 23, Firenze, Italy',
  categories: ['Italian', 'Pizzeria', 'Vegetarian', 'Organic'],
  starterMenu: ['Focaccia', 'Bruschetta', 'Garlic Bread', 'Caprese Salad'],
  mainMenu: ['Pizza', 'Pasta', 'Risotto'],

  openingHours: {
    thu: {
      open: 12,
      close: 22,
    },
    fri: {
      open: 11,
      close: 23,
    },
    sat: {
      open: 0, // Open 24 hours
      close: 24,
    },
  },


  //destructering objects with variable name same as object property name.
  const { name, openingHours, categories } = restaurant;
  console.log(name, openingHours, categories);

  //destructering objects with variable name not same as object property name.

  const {
    name: restaurantName,
    categories: restaurantCategories,
    openingHours: restaurantOpeningHours,
  } = restaurant;

  console.log(
    `destructering objects with variable name not same as object property name`
  );
  console.log(restaurantName, restaurantCategories, restaurantOpeningHours);

  //re assignging using de structering

  let a = 120;
  let b = 123;
  const obj = {
    a: 1,
    b: 2,
  };
  console.log(a, b);
  ({ a, b } = obj); // to use destructering while re-assigning we have to wrap in () or else js will take {} as a code block and throw error
  console.log(a, b);

  //nested object desturctering
  //here we are nesting the internal object while destructering
  const {
    fri: { open: o, close: c },
  } = openingHours;
  console.log(o, c);

  //the real practical example of destructering is when we de structre the values in the function parameter at runtime
  restaurant.orderDelivery({
    time: '22:30',
    address: '06,baguiati road',
    mainIndex: 2,
    startIndex: 2,
  });

  //de structering object in function where we dont send all the properties of the object and use default value in the function for missing properties.
  restaurant.orderDelivery({
    time: '22:30',
    address: '06,baguiati road',
  });

  //spread operator (...) is used to expand the array into all its elements,unpacking all elements all at once.

  const arr = [1, 2, 3];
  console.log(...arr); // the array gets spread and output is 3 individual values 1 2 3
  //creating new array from the above array along with some new elements without spread operator here we have a draw back we need to know the total elements of array and if the array is long then we have to write all the elements here.
  const arr1 = [4, 5, arr[0], arr[1], arr[2]];
  console.log(arr1);

  // doing the same with spread operator
  const arr2 = [7, 8, ...arr];
  //here ...arr spreads the arr array and expands the elemnts element inside the new array
  console.log(arr2);

  const newMenu = [...restaurant.mainMenu, 'Gnocci'];
  console.log(newMenu);
  //difference between spread operator and destrutering is that spread operator takes all the elements from the array and do not assign them into variables.

  //spread operator has 2 use cases a) make shallow copies of array and b) merge two arrays together.

  //shallow copies of array using spread operator
  const mainMenuCopy = [...restaurant.mainMenu];

  //merge 2 arrays
  const startMenuMainMeuMerge = [
    ...restaurant.starterMenu,
    ...restaurant.mainMenu,
  ];
  console.log(startMenuMainMeuMerge);
  // spread operator works on all iterables : Arrays,Sets,Maps,Strings , objects are not iterable.
  const str = 'Jonas';
  const letters = [...str, ' ', 'S.']; //the letters of the string is split into character array.
  console.log(letters);

  //spread operator is not usable inside evaluation of template string

  //this function is accepting a 3 variables and instead of sending each element of the array we are spreading the array and which gets stroed in each of the parameter.
  const function1 = function (a, b, c) {
    console.log(a, b, c);
  };
  function1(...arr);

  //from ES-2018 ... (spred operator) works on objects even though objects are not iterables.
  const newResturant = { ...restaurant }; //copy the resturant object into the new object we can also use Object.assign()
  console.log(newResturant);

Rest Operator:
//looks same as spread operator but works in opposite fashion ,collects multiple element and condenses into an array
  //spread because ... is on right side of '='
  const arr = [1, 2, , ...[3, 4]];
  console.log(arr);
  //rest because '...' is on left side of '='
  const [a, b, ...others] = [1, 2, 3, 4, 5, 6]; //here first two elemetn of the array gets stored in a and b and the remaining array elements gets stored into new  array named others
  //rest opearator is used during deStructering process
  //rest operator will always be at last in the desturctering assignment
  // const [pizza, rissoto, ...otherFood] = [...restaurant.mainMenu,...restaurant.starterMenu]; wrong
  //combination of rest operator and spread operator together.
  console.log(a, b, others);
  const [pizza, rissoto, ...otherFood] = [
    ...restaurant.mainMenu,
    ...restaurant.starterMenu,
  ];
  console.log(pizza, rissoto, otherFood);

  //using rest paramter with function , its similar to varargs in java , but difference is when we call the function with multiple params it gets clubbed into an array and collected inside the method

  const f1 = function (...values) {
    console.log(values);
  };

  f1(1, 2, 3);
  f1(1);
  f1(1, 2, 3, 4, 5, 6);

  const sum = function (...values) {
    let s = 0;
    for (let i = 0; i < values.length; i++) {
      s += values[i];
    }
    console.log(`sum is ${s}`);
  };

  sum(1, 2);
  sum(1, 2, 3, 4);

  // we can also send an array to the sum() method but while calling we have to spread the values so that it can be collected and again condensed into an array in the method
  sum(...[7, 8, 9]);


  //short circuit operator (|| &&)
//in case of || if the first value is truely then seccond expression is not evaluated and first value is returned
//in case of && if the 1st value/expression is falsey then seccond expression is not evaluated and the 1st value/expression is evaluated and returned



//nullish coalescing operator(??)
// in case of ?? operator if the first expression is null or undefined then only it will evaluate the seccond expression else evaluate the 1st expression introduced in ES2020.
console.log(0 || 10); // 10
console.log(0 ?? 10); //0



//logical assignment operator
//introduced in ES2021
// ||=(or assignment)  ??=(null coalescing assignment) &&=(and assignment)

const rest1 = {
  name: 'Capri',
  numGuest: 0,
};
const rest2 = {
  name: 'La Piaza',
  owner: 'Giovani',
};

// assigning new property based on short circuting
// rest1.numGuest = rest1.numGuest || 10;
rest1.numGuest ??= 10; //using logical assignment
// rest2.numGuest = rest2.numGuest || 10;
rest2.numGuest ??= 10; //using logical assignment
console.log(rest1);
console.log(rest2);

//for of loop
 const menu = [...restaurant.starterMenu, ...restaurant.mainMenu];
  //loops through the content of an iterable in this case an array
  for (const item of menu) {
    console.log(item);
  }
  //in order to get position of each element in array for for of loop we have to call the loop with .entries() method after the array
  //entries()-> Returns an iterable of key, value pairs for every entry in the array
  for (const item of menu.entries()) {
    console.log(item); //[<index>,<content at the index>]
  }
  //since each entry is a [key,value] pair we can use the destructering property inside for of loop while using entries to store key and value in separate constants.
  for (const [key, value] of menu.entries()) {
    console.log(`${key + 1}: ${value}`);
  }




 // ES6 introduced 3 ways which we can use to define object in object literal format
  //1.if we want to include one object into another object as property we can directly put the variable name of the object we want to include/add into the target object name
  //2. in case of defining function inside an object literal we dont need to use the keyword function anymore just use () with the property name and that property will be function
  //3. we can use expression to evaluate both keys and values inside object literal definition but that has to be enclosed within [].
  const days = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'];
  const openingHours = {
    [days[0]]: {
      open: 12,
      close: 22,
    },
    [days[2]]: {
      open: 11,
      close: 23,
    },
    [days[days.length - 1]]: {
      open: 0, // Open 24 hours
      close: 24,
    },
  };
  console.log(openingHours);
  const resturantCopy = {
    name: 'Classico Italiano',
    location: 'Via Angelo Tavanti 23, Firenze, Italy',
    categories: ['Italian', 'Pizzeria', 'Vegetarian', 'Organic'],
    starterMenu: ['Focaccia', 'Bruschetta', 'Garlic Bread', 'Caprese Salad'],
    mainMenu: ['Pizza', 'Pasta', 'Risotto'],
    //old method
    //openingHours:openingHours
    //new way
    openingHours, // this will create a new property with the same name as the variable
    //in this method while calling it we are sending the entire object and in the function body we are using the destructering property to destructre the object into variables also we can add default value to this de-structured variable in case the object dont send those property,which is a good programming practice and if dont use can lead to undefined value and hence error.
    //here we dont need to write function keyword automatically orderDeilvery will be a function
    orderDelivery({ time, startIndex = 0, mainIndex = 0, address }) {
      console.log(
        `order recieved! ${this.starterMenu[startIndex]} and ${this.mainMenu[mainIndex]} will be delivered at ${address} at time ${time}`
      );
    },
    loggerFunc() {
      console.log('hello world!!');
    },
  };


Optional chaining(?.)
//the optional chaning is used to check the left side of a . operation has value or not if it has value(not undefined or null) then the . operator will execute else undefined will be returned
  //its more like an optional check where if not used may lead to error

  const days = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'];
  const openingHours = {
    [days[0]]: {
      open: 12,
      close: 22,
    },
    [days[2]]: {
      open: 11,
      close: 23,
    },
    [days[days.length - 1]]: {
      open: 0, // Open 24 hours
      close: 24,
    },
    func1() {
      return 'hello';
    },
  };
  // console.log(openingHours.mon.open); // will lead to error as days.mon=undefined(Cannot read properties of undefined)
  /*without optional chaining we have to do a if else check
  if (openingHours.sun && openingHours.sun.open) {
    console.log(openingHours.sun.open);
  }*/

  //with optional chaining
  //?. checks if the property to the right of '?' exists if yes then it executes the next property with . else return undefined.
  console.log(openingHours?.mon?.open); //undefined
  console.log(openingHours?.sun?.open); //12

  //using optional check with function
  console.log(openingHours.func1?.()); //hello
  console.log(openingHours.func2?.()); //undefined checks if func2 exists if yes then calls else returns undefined
  console.log(openingHours.func2?.() ?? 'Function does not exists'); //combining with null colescion operator.



   //we can loop over objects in various ways by property name,by value ,by entry(property,value paid)
  //loop via property name(keys)
  const days = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'];
  const openingHours = {
    [days[0]]: {
      open: 12,
      close: 22,
    },
    [days[2]]: {
      open: 11,
      close: 23,
    },
    [days[days.length - 1]]: {
      open: 0, // Open 24 hours
      close: 24,
    },
  };
  //Object.keys(<object_name>) is an inbuild method that returns an array that consists of the keys of the given object passed.
  for (const day of Object.keys(openingHours)) {
    console.log(day);
  }
  //Object.values(<object_name>) is an inbuild method that returns an array that consists of the values of the given object passed.
  //loop via value
  console.log(Object.values(openingHours));

  //Object.entries(<object_name>) this will give an array of entries(key,value) where each element is key,value pair of the object
  console.log(Object.entries(openingHours));
  //example of using destructering inside for of loop where we are looping through the entry set of the given object
  for (const [key, { open, close }] of Object.entries(openingHours)) {
    console.log(`on ${key} we open at ${open} and close at ${close}`);
  }


  Sets:


  //before js did not had many inbuild data structures but with ES6 new data structres like sets and maps were introduced
  //to create a new set we have to do with new keyword as shown below new set(<iterable>) and pass an array/string/set/map or any iterable inside the constructor parameter.like java sets in javascript also don not allow duplicates and also does not maintain insertion order.
  const arr1 = ['pasta', 'pizza', 'pizza'];
  const set1 = new Set(arr1);
  console.log(set1); //[pasta,pizza]
  const set2 = new Set('Jonas');
  console.log(set2);
  //to check length of set we use  size method on set
  console.log(set1.size);
  //hase() method of set a boolean indicating whether an element with the specified value exists in the Set or not.
  console.log(set1.has('pizza'));
  //to add new element to a set we use the add() method
  set1.add('rissotto'); //Appends a new element with a specified value to the end of the Set.
  set1.add('apple');
  set1.delete('apple'); //Removes a specified value from the Set. @returns Returns true if an element in the Set existed and has been removed, or false if the element does not exist.
  //like array we cannot display an element of set using its index
  console.log(set1[0]); //undefined no matter whatever we pass in the index , in sets there is no indexes and there is no way we can directly get one element from set , we have to always traverse the set
  // to clear a set we use clear() method
  // set1.clear() //
  // as set is iterable so we can use loops to traverse through set.
  for (const val of set1) {
    console.log(val);
  }
  const arr2 = [...set1]; // this will first spread the set and then with the new values create an array containing only unique elements.
  console.log(arr2);




  Maps:
  const openingHours = {
    thu: {
      open: 12,
      close: 22,
    },
    fri: {
      open: 11,
      close: 23,
    },
    sat: {
      open: 0, // Open 24 hours
      close: 24,
    },
  };
  //like objects data in maps are stored in key,value pairs ,but the big difference between objects and maps are , in objects the keys are basically always string and in maps keys can be of any type.
  // we use the new keyword to create a map
  const resturantMap = new Map();
  //we use the set keyword to add new key,value pair in map and returns the map
  resturantMap.set('name', 'classico Italiano'); //Adds a new element with a specified key and value to the Map. If an element with the same key already exists, the element will be updated.
  resturantMap.set(1, 'Frenze, Italy');
  resturantMap.set(2, 'Lisbon, Portugal');
  //since set method of map returns the mao we can use that  for chaining set methods
  console.log(
    resturantMap
      .set('categories', ['Italian', 'Pizzeria', 'Vegetarian', 'Organic'])
      .set('starterMenu', [
        'Focaccia',
        'Bruschetta',
        'Garlic Bread',
        'Caprese Salad',
      ])
  );

  //to retrive value from set we use the get(<key_name>) method to get value for given key
  /*
  Returns a specified element from the Map object. If the value that is associated to the provided key is an object, then you will get a reference to that object and any change made to that object will effectively modify it inside the Map.
     * @returns Returns the element associated with the specified key. If no element is associated with the specified key, undefined is returned
   */
  console.log(resturantMap.get('starterMenu'));
  //to check if an element is present we use has()
  console.log(resturantMap.has(1)); // boolean indicating whether an element with the specified key exists or not.
  //resturantMap.clear(); // to clear the map
  //resturantMap.delete(1); // delete the key value pair for the given key
  //if we use object as key then first we should store that object and use the same refference otherwise it will create dumb entires as shown below
  resturantMap.set([1, 2], 'hello');
  console.log(resturantMap.get([1, 2])); //undefiend although we are passing same array in set and get method but inernally those arrays are 2 different object and hence not the same

  const arr = [3, 4];
  resturantMap.set(arr, 'hi');
  console.log(resturantMap.get(arr)); //hi ,also since the key here is an object refference so if we change the or add elements to the array the key will change as the key is not holding the array but a reffeence to the array object.

  //map iteration
  //we can define map and intialize it on the spot as an array of array , where each innner array is an entry having 2 elements key and value
  const question = new Map([
    ['question', 'what is the best programming language in the world'],
    [1, 'Java'],
    [2, 'C++'],
    [3, 'JavaScript'],
    ['correct', 3],
    [true, 'correctðŸ¥³'],
    [false, 'Try Again!!'],
  ]);
  //we can also create a map from using Object.entries() on a given object
  console.log(Object.entries(openingHours));
  const map3 = new Map(Object.entries(openingHours)); //the inner object.entires will convert the object into key value entries which will be used to create the map
  console.log(map3);
  console.log(question.get('question'));
  //as map is already list of entries so we can directly use for of loop in the map as Object.entries() for of loop in object shown below
  for (const [key, value] of question) {
    if (typeof key === 'number') {
      console.log(`Anwer is ${key}:${value}`);
    }
  }
  const ans = Number(prompt('Enter your answer'));
  console.log(question.get(question.get('correct') === ans));
  //convert map into array of arrays , if we use spread operator on a map then the result will be an array of arrays as shown below.
  const arrQuestion = [...question];
  console.log(arrQuestion);
  //map also has 3 inbuild methods .entries() which give the entries of the map,.keys()  gives key of map and .values() give values array but all of these gives a mapIterator as output we have to spread the result and store in an array in order to use it.
  console.log([...question.entries()]);
  console.log([...question.keys()]);
  console.log([...question.values()]);


  Selecting Data structres based on problem:
  There are 3 sources of data
  1. From the program itself: Data written directly in source code eg: status_code constant ,etc.
  2. From the UI: Data input from the user or written in DOM.
  3. From external soruces: Data comming from WEB API's.

  If the data is liner (not key value pair) then we can use either arrays or sets and if the data is in form of any key value pair we can use either objects or maps.

  Other build in ds of js are weakMap and weakSet 
  and non build in ds in js but we use are stack,queue,linkedList,hashTable,Trees.
  



  